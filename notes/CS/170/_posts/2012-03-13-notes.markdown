---
layout: notes
title: CS 170 Lecture 14
topic: Dynamic Programming
---

# Dynamic Programming

* Increasing subsequence DAG
* Knapsack DAG

$!n^2!$ subproblems, where you need to look at $!n!$ other subproblems each
time. Therefore the running time is: $$O(n^3)$$

## How can we improve on DP?

$$900,300,400,200,1100;2000$$

is the same as:

$$9,3,4,2,11;20$$


## A new kind of problem

Independent set problem.

     /-------\
     o - o - o
    /| / | \ | \
    |o - o - o - o
    \| \ | / | /
     o - o - o
     \-------/

NP complete problem.

If the given graph is a tree, the problem is easily solved with dynamic
programming!
     
            o
      /----/|\-----\
     o      |      o
    /|\     o     / \
    ooo    / \    o o
           | o
          / \
          o o

Dynamic programming for tree. 

    Sub problem = Sub tree(Vertex)

Algorithm:

    For every node of the tree from the leaves up:
      if v is a leaf:
        I(v) = 1
      else:
        I(v) = max($!\sum_{\text{u, child of v}} I(u)!$, $!1 + \sum_{\text{u, grandchild of v}} I(u)!$)


Very useful for solving hard problems on trees.

## Shortest Path (With a twist)

Shortest path from $!s!$ with $!\le k!$ hops.

Penalized long paths!

DYNAMICPROGRAMMING!!!!!!!!!

    For every node in the tree:
      $$dist[v, k] = \text{The length of the shortest path from s to v, with k
                           edges}\\

      dist[v, 0] = 0\text{, or }\infty\\

      dist[v, k] = \min_{(u,v)\in E}[dist[u, k-1] + l[u,v]]$$

### All-pairs shortest path

> We want the shortest paths between all possible pairs of nodes, at once.

### Floyd-Warshall $!O(|V|^3)!$

Shortest path from $!i!$ - $!j!$.

Imagine that we slowly find better and better shortest paths.

Which intermediate nodes can we use?

At beginning, no intermediate nodes

Then we add one node, then two, then ...

> Subproblem k: shortest paths using an intermediate nodes only $!\\{1, 2, \dots,
> k\\}!$

Each time we add a new intermediate node k, we either use, or don't use the node
k. 

__Floyd Warshall__
     
    dist[i, j, 0] = l[i,j]

    for k = 1 to n:
      for i = 1 to n:
        for j = 1 to n:
          dist[i, j, k] = min[dist[i, j, k-1], dist[i,k,k-1] + dist[k,j,k-1]]

If there is a negative number in the result matrix, then we are guaranteed to
have a negative cycle. Making negative cycle checking very easily.


### Is there a directed path from i -> j?

___Floyd-Warshall solves this problem!___

    dist[i, j, 0] = 0 if no edge
    dist[i, j, 0] = 1 if edge

    for k = 1 to n:
      for i = 1 to n:
        for j = 1 to n:
          dist[i, j, k] = or[dist[i, j, k-1], dist[i,k,k-1] and dist[k,j,k-1]]

### Traveling Salesman!!!!!!

NP-Complete

$$n! \rightarrow 2^n$$

To find the shortest path without too many hops, we have to remember how many
hops we have done so far. 

$$S \subseteq \text{Cities}, 1 \in S$$

    L(S, j)
      j in S
      j not 1

The length of the shortest way to start from 1, visit all cities in S and end up
in j

    For all S in increasing size $!\ge 2!$:
      for all $!j \in S, j \neq 1!$
        L(S, j) = $!\min_{i \in SS, i \neq j} L(S-\{j\}, i) + l(i, j)!$
    return $!\min_j L(\{1, 2, 3, \dots, n\}, j) + l(j, 1)!$

Running time is then $!O(2^n)!$.

> The only advice I can give you about dynamic programming is "Solve problems"
> ~Papadimitrou
