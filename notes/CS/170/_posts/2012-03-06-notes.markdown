---
layout: notes
title: CS 170 Lecture 12
---

# Set Cover

K lists that cover.

    [.....]
    [.....]
    [.....]
    [.....]

Except for the other lists. 

The greedy algorithm is not optimal, but will find a very good solution. 

> This problem is ***NP-Complete***. 

The greedy algorithm picks the set with the most remaining elements. 

* not optimal, but will perform fine.

## How fine?

The optimal has k sets.

The greedy alway picks at least 1/k remaining elements.

    After Step 1:
      Elements remaining <= n(1 - 1/k)
    After Step 2:
      Elements remaining <= n(1 - 1/k)^2
    After Step k:
      Elements remaining <= n(1 - 1/k)^k = 1/e = 37% < 1/2
    After Step klogn:
      Elements remaining = 0

> There is a solution that has k, therefore we will always have an element of
size (1/k) which is a set from the optimal solution. The greedy will always try
to do better.

# Dynamic Programming!!!!!!!!!!!!!!!!!!!!!!!

Divide and conquer is not applicable most of the time. 

      3     6
    s -> c -> d
    v 5  v 2  v 2
    a -> b -> e
      1    4

    dist[s] = 0
    for each vertex v in linearized order
      dist[v] = min u in pred(v) [ dist[v] + l[u,v] ]
