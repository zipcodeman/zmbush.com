---
layout: notes
title: CS 170 Lecture 12
---

# Set Cover

K lists that cover.

    [.....]
    [.....]
    [.....]
    [.....]

Except for the other lists. 

The greedy algorithm is not optimal, but will find a very good solution. 

> This problem is ***NP-Complete***. 

The greedy algorithm picks the set with the most remaining elements. 

* not optimal, but will perform fine.

## How fine?

The optimal has k sets.

The greedy alway picks at least 1/k remaining elements.

    After Step 1:
      Elements remaining <= n(1 - 1/k)
    After Step 2:
      Elements remaining <= n(1 - 1/k)^2
    After Step k:
      Elements remaining <= n(1 - 1/k)^k = 1/e = 37% < 1/2
    After Step klogn:
      Elements remaining = 0

> There is a solution that has k, therefore we will always have an element of
size (1/k) which is a set from the optimal solution. The greedy will always try
to do better.

# Dynamic Programming!!!!!!!!!!!!!!!!!!!!!!!

Divide and conquer is not applicable most of the time. 

      3     6
    s -> c -> d
    v 5  v 2  v 2
    a -> b -> e
      1    4

To Solve this DAG, we can do the following

    dist[s] = 0
    for each vertex v in linearized order
      dist[v] = min u in pred(v) [ dist[u] + l[u,v] ]

This algorithm is extremely robust an versatile. This is all that Dynamic
Programming really is. 

## Versatile!

Suppose we want to find the longest path. 

* min -> max

Suppose we want to find the smallest product!

* plus -> times

Simple changes can make this algorithm do what you want!

    dist[v] = f(u1, ..., uk, data), where the uns are predecessors of v.

We can put anything in this function!

We can solve a host of problems. 

An algorithm that can solve many problems is called dynamic programming. 

> "Can we map it to a dag and solve it?"

### Let's solve a problem!

    5 2 8 6 3 6 9

Find the longest increasing subsequence

Let's modify our algorithm!!

    for each vertex v in linearized order
      L[v] = max u in pred(e) L[u] + 1

Edit distance, The number of edits required to turn one string into another. 

CATFISH -> SATISH = 2

Papadimitrou - patronizing = ?

Sequence alignment:

    S A T _ I S H
    C A T F I S H

Human genome has a very small edit distance from the mouse genome.

[Blast!](http://en.wikipedia.org/wiki/BLAST)


