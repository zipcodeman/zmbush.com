% Search for all the places that say "PUT SOMETHING HERE".

\documentclass[11pt]{article}
\usepackage{amsmath,textcomp,amssymb,geometry,graphicx}

\def\Name{Zachary Bush}  % Your name
\def\Sec{Th 4-5; Starfield}  % Your discussion section
\def\Login{cs170-nx} % Your login

\title{CS170--Spring 2012 --- Solutions to Homework 5}
\author{\Name, section \Sec, \texttt{\Login}}
\markboth{CS170--Spring 2012 Homework 5 \Name, section \Sec}{CS170--Spring 2012 Homework 5 \Name, section \Sec, \texttt{\Login}}
\pagestyle{myheadings}

\begin{document}
\maketitle

\section*{1.}
Given an undirected graph G, you can run a depth first search. At each level,
the number of paths to a given node is equal to the sum of the paths to its
direct parents plus the number of parents it has. In this way, we keep the
linear time operation of BFS, while keeping track of the number of paths to any
arbitrary elements in the graph

\newpage
\section*{2.}
Collaborators: Nathan Rockenbach

We look at the tree we were given and traverse through it to calculate the
distance values for each element in the tree. These values will be stored in a
hashtable for later use. If the tree is a minimum tree, then these values will
be the minimum distances from the initial node. To prove that this is not a
minimum tree, we must find some edge that is shorter than the chosen edges. 

From there we start from the root node of the initial tree, we add all of its
incident edges into the fringe to be checked. The fringe will be processed like
a queue in the style of a breadth first search. 

For each of these edges (A, B) we calculate if the distance to the start node
(A) plus the weight of the edge is less than the distance to B. If this is the
case, then there is a shortcut to B that is not taken by the original tree
traversal. In this way, we find that the tree is not a minimum tree. 

If we find no such shortcut, then the tree is guaranteed to be a minimum tree. 

\newpage
\section*{3.}
For this to work, all we have to do is slightly modify djikstra's algorithm.
What we do is, in addition to keeping track of the minimum distance to a node,
we also keep track of the number of jumps it took to get there. If we find a
distance that is the same but with fewer jumps, then we have a more efficient
path, and we replace the previous path with the new one. Thus we have the same
running time as djikstra's and we discover the minimum number of jumps in a
minimum weight path to every node. 
\newpage
\section*{4.}
Collaborator: Greg Shuflin, Nathan Rockenbach, Hayg Astorian
\begin{itemize}
\item[(a)] 

Assuming that all exchange rates are greater than zero. 

Since we need to maximize the product of the exchange rates from one
currency to another, then we can reformulate the weights of the edges to be
represented as: $-log(\text{exchange rate})$. In this way, we can instead
minimize the sum of the weights.

After we represent our graph in this way, we can run the Bellman-Ford algorithm
on the graph (we can't use djikstra because we have negative path length) to
find the optimal path to the node we want. 

\item[(b)]

After running Bellman-Ford, all we need to do is run the update procedure
again. If there any of the weights are updated, then we have a negative cycle.
Otherwise, there is no such cycle.
\end{itemize}

\newpage
\section*{5.}

\begin{itemize}
\item[(a)]
The cost of its mst is: 19
\item[(b)]
This graph has 2 minimum spanning trees, you have the choice of either 2
weighted edge from B.
\item[(c)]
The edge connecting A and E is added first. It connects two trees A and E.

The edge connecting E and F is added next. It connects two trees AE and F.

The edge connecting E and B is added next. It connects two trees AEF and B.

The edge connecting F and G is added next. It connects two trees ABEF and G.

The edge connecting G and H is added next. It connects two trees ABEFG and H.

The edge connecting G and C is added next. It connects two trees ABEFGH and C.

The edge connecting G and D is added next. It connects two trees ABCEFGH and D.

And we are done.

\end{itemize}

\newpage
\section*{6.}
We are guaranteed that for any component with $v$ vertices, then we have at
least $v - 1$ edges.

If we let $v_i$ be equal to the number vertices in component $i$, then we can
say that the sum of the number of vertices $e'$ is:
\begin{equation*}
e' \ge \sum_{i=1}^{k} (v_i - 1)
\end{equation*}

This sum can also be represented as: 
\begin{eqnarray*}
\sum_{i=1}^{k} (v_i - 1) &=& \sum_{i=1}^k v_i - \sum_{i=1}^{k} 1\\
&=& n - k
\end{eqnarray*}

Which means that the number of edges $e'$ is at the very least $n-k$.
\end{document}
